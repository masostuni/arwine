<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>AR Autonomo: Modello "wine" con WebXR</title>
    <style>
      body { margin: 0; overflow: hidden; }
      canvas { display: block; }
    </style>
  </head>
  <body>
    <!-- Includiamo Three.js, ARButton e GLTFLoader dalla CDN -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.154.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.154.0/examples/jsm/webxr/ARButton.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.154.0/examples/jsm/loaders/GLTFLoader.js"></script>
    
    <script>
      let camera, scene, renderer;
      let controller;
      let reticle;
      let hitTestSource = null;
      let hitTestSourceRequested = false;
      let wineModel = null;
      let selectedModel = null; // Ultimo modello posizionato per pinch-to-zoom
      
      // Variabili per pinch-to-zoom
      let prevDistance = null;
      
      init();
      animate();
      
      function init() {
        // Creazione della scena
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);
        
        // Configurazione del renderer e abilitazione di WebXR
        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.xr.enabled = true;
        document.body.appendChild(renderer.domElement);
        
        // Bottone AR per attivare la modalità AR (richiede 'hit-test')
        document.body.appendChild(ARButton.createButton(renderer, { requiredFeatures: ['hit-test'] }));
        
        // Aggiungiamo una luce ambientale
        const light = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 1);
        light.position.set(0.5, 1, 0.25);
        scene.add(light);
        
        // Creazione del reticle per il posizionamento
        reticle = new THREE.Mesh(
          new THREE.RingGeometry(0.15, 0.2, 32).rotateX(-Math.PI / 2),
          new THREE.MeshBasicMaterial({ color: 0x00ff00 })
        );
        reticle.matrixAutoUpdate = false;
        reticle.visible = false;
        scene.add(reticle);
        
        // Controller per interazioni AR
        controller = renderer.xr.getController(0);
        controller.addEventListener('select', onSelect);
        scene.add(controller);
        
        // Caricamento del modello "wine"
        const loader = new THREE.GLTFLoader();
        loader.load('wine.glb', function(gltf) {
          wineModel = gltf.scene;
          console.log('"wine" model loaded successfully.');
        }, undefined, function(error) {
          console.error('Errore nel caricamento del modello "wine":', error);
        });
        
        // Event listeners per pinch-to-zoom
        renderer.domElement.addEventListener('touchstart', onTouchStart, false);
        renderer.domElement.addEventListener('touchmove', onTouchMove, false);
        renderer.domElement.addEventListener('touchend', onTouchEnd, false);
        
        window.addEventListener('resize', onWindowResize, false);
      }
      
      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }
      
      // Evento select: posiziona il modello "wine" dove il reticle è visibile
      function onSelect() {
        if (reticle.visible && wineModel) {
          // Clona il modello wine e posiziona la copia
          const modelClone = wineModel.clone();
          modelClone.position.setFromMatrixPosition(reticle.matrix);
          modelClone.scale.set(0.5, 0.5, 0.5);
          scene.add(modelClone);
          // Imposta il modello posizionato come selezionato per eventuali operazioni di scaling
          selectedModel = modelClone;
        } else {
          console.warn('Reticle non visibile o modello "wine" non ancora caricato.');
        }
      }
      
      // Gestione degli eventi touch per il pinch-to-zoom
      function onTouchStart(event) {
        if (event.touches.length === 2) {
          prevDistance = getDistance(event.touches[0], event.touches[1]);
        }
      }
      
      function onTouchMove(event) {
        if (event.touches.length === 2 && selectedModel) {
          const newDistance = getDistance(event.touches[0], event.touches[1]);
          if (prevDistance) {
            const scaleFactor = newDistance / prevDistance;
            selectedModel.scale.multiplyScalar(scaleFactor);
          }
          prevDistance = newDistance;
        }
      }
      
      function onTouchEnd(event) {
        if (event.touches.length < 2) {
          prevDistance = null;
        }
      }
      
      function getDistance(touch1, touch2) {
        const dx = touch2.clientX - touch1.clientX;
        const dy = touch2.clientY - touch1.clientY;
        return Math.sqrt(dx * dx + dy * dy);
      }
      
      // Loop di animazione e gestione hit-test
      function animate() {
        renderer.setAnimationLoop(render);
      }
      
      function render(timestamp, frame) {
        if (frame) {
          const referenceSpace = renderer.xr.getReferenceSpace();
          const session = renderer.xr.getSession();
          
          if (!hitTestSourceRequested) {
            session.requestReferenceSpace('viewer').then(viewerReferenceSpace => {
              session.requestHitTestSource({ space: viewerReferenceSpace }).then(source => {
                hitTestSource = source;
              });
            });
            session.addEventListener('end', () => {
              hitTestSourceRequested = false;
              hitTestSource = null;
            });
            hitTestSourceRequested = true;
          }
          
          if (hitTestSource) {
            const hitTestResults = frame.getHitTestResults(hitTestSource);
            if (hitTestResults.length > 0) {
              const hit = hitTestResults[0];
              const pose = hit.getPose(referenceSpace);
              reticle.visible = true;
              reticle.matrix.fromArray(pose.transform.matrix);
            } else {
              reticle.visible = false;
            }
          }
        }
        renderer.render(scene, camera);
      }
    </script>
  </body>
</html>
