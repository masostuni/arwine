<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>MVP AR: "Wine" con Surface Detection e Pinch Zoom</title>
    <style>
      body { margin: 0; overflow: hidden; }
      canvas { display: block; }
    </style>
  </head>
  <body>
    <!-- Includiamo Three.js, ARButton e GLTFLoader dalla CDN -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.154.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.154.0/examples/jsm/webxr/ARButton.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.154.0/examples/jsm/loaders/GLTFLoader.js"></script>
    
    <script>
      let camera, scene, renderer;
      let controller;
      let reticle;
      let hitTestSource = null;
      let hitTestSourceRequested = false;
      let wineModel = null; // Modello "wine" caricato
      let selectedModel = null; // Ultimo modello posizionato (selezionato)
      
      // Variabili per il pinch-to-zoom
      let prevDistance = null;
      
      init();
      animate();
      
      function init() {
        // Creazione della scena e della camera
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);
        
        // Renderer con supporto per WebXR
        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.xr.enabled = true;
        document.body.appendChild(renderer.domElement);
        
        // Bottone per entrare in AR, richiede la feature hit-test
        document.body.appendChild(ARButton.createButton(renderer, { requiredFeatures: ['hit-test'] }));
        
        // Luce ambientale
        const light = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 1);
        light.position.set(0.5, 1, 0.25);
        scene.add(light);
        
        // Reticle per indicare il punto di posizionamento sulla superficie
        reticle = new THREE.Mesh(
          new THREE.RingGeometry(0.15, 0.2, 32).rotateX(-Math.PI / 2),
          new THREE.MeshBasicMaterial({ color: 0x00ff00 })
        );
        reticle.matrixAutoUpdate = false;
        reticle.visible = false;
        scene.add(reticle);
        
        // Controller per gestire l'interazione (es. tocco per posizionare il modello)
        controller = renderer.xr.getController(0);
        controller.addEventListener('select', onSelect);
        scene.add(controller);
        
        // Carica il modello "wine" una sola volta
        const loader = new THREE.GLTFLoader();
        loader.load('wine.glb', function(gltf) {
          wineModel = gltf.scene;
          console.log('"wine" model loaded successfully.');
        }, undefined, function(error) {
          console.error('Errore nel caricamento del modello "wine":', error);
        });
        
        // Event listeners per il pinch-to-zoom
        renderer.domElement.addEventListener('touchstart', handleTouchStart, false);
        renderer.domElement.addEventListener('touchmove', handleTouchMove, false);
        renderer.domElement.addEventListener('touchend', handleTouchEnd, false);
        
        window.addEventListener('resize', onWindowResize, false);
      }
      
      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }
      
      // Funzione per gestire l'evento "select" del controller: posiziona il modello "wine"
      function onSelect() {
        if (reticle.visible && wineModel) {
          // Clona il modello "wine" e lo posiziona dove il reticle Ã¨ visibile
          const modelClone = wineModel.clone();
          modelClone.position.setFromMatrixPosition(reticle.matrix);
          // Imposta una scala iniziale (modifica se necessario)
          modelClone.scale.set(0.5, 0.5, 0.5);
          scene.add(modelClone);
          // Rende il modello clonato "selezionato" per eventuali operazioni di zoom
          selectedModel = modelClone;
        } else {
          console.warn('Reticle non visibile o modello "wine" non ancora caricato.');
        }
      }
      
      // Funzioni per il pinch-to-zoom
      function handleTouchStart(event) {
        if (event.touches.length === 2) {
          prevDistance = getDistance(event.touches[0], event.touches[1]);
        }
      }
      
      function handleTouchMove(event) {
        if (event.touches.length === 2 && selectedModel) {
          const newDistance = getDistance(event.touches[0], event.touches[1]);
          if (prevDistance) {
            const scaleFactor = newDistance / prevDistance;
            // Aggiorna la scala del modello selezionato
            selectedModel.scale.multiplyScalar(scaleFactor);
          }
          prevDistance = newDistance;
        }
      }
      
      function handleTouchEnd(event) {
        if (event.touches.length < 2) {
          prevDistance = null;
        }
      }
      
      function getDistance(touch1, touch2) {
        const dx = touch2.clientX - touch1.clientX;
        const dy = touch2.clientY - touch1.clientY;
        return Math.sqrt(dx * dx + dy * dy);
      }
      
      // Loop di animazione
      function animate() {
        renderer.setAnimationLoop(render);
      }
      
      // Rendering e gestione dell'hit-test per il surface detection
      function render(timestamp, frame) {
        if (frame) {
          const referenceSpace = renderer.xr.getReferenceSpace();
          const session = renderer.xr.getSession();
          
          if (!hitTestSourceRequested) {
            session.requestReferenceSpace('viewer').then(function(viewerReferenceSpace) {
              session.requestHitTestSource({ space: viewerReferenceSpace }).then(function(source) {
                hitTestSource = source;
              });
            });
            
            session.addEventListener('end', function() {
              hitTestSourceRequested = false;
              hitTestSource = null;
            });
            
            hitTestSourceRequested = true;
          }
          
          if (hitTestSource) {
            const hitTestResults = frame.getHitTestResults(hitTestSource);
            if (hitTestResults.length) {
              const hit = hitTestResults[0];
              const pose = hit.getPose(referenceSpace);
              reticle.visible = true;
              reticle.matrix.fromArray(pose.transform.matrix);
            } else {
              reticle.visible = false;
            }
          }
        }
        renderer.render(scene, camera);
      }
    </script>
  </body>
</html>
